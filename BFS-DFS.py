# -*- coding: utf-8 -*-
"""A01_18I-1587.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vLw4VLIkWZF1-c5UKVB9Uk8_eDe-jFWQ
"""

import sys
from copy import copy, deepcopy
from collections import deque
################################################# VARIABLES #################################################
maze=[ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0 ,1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
       [0 ,1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
       [0 ,0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0],
       [0 ,1, 1, 1, 1, 0, 0, 0, 1, 0, 1,'*'],
       [0 ,0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
       [0 ,0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
       [1 ,1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
       [0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

goal_state=[ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0 ,1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
       [0 ,1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
       [0 ,0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0],
       [0 ,1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1],
       [0 ,0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
       [0 ,1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
       [0 ,0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
       ['*' ,1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
       [0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]


################################################# NODE CLASS #################################################
class Node:
    def __init__(self, st, parent, operator, cost):
        self.st = st
        self.parent = parent
        self.operator = operator
        self.cost = cost

def create_node(st, parent, operator, cost):
    return Node(st, parent, operator, cost)

################################################# MOVEMENTS ##################################################

def move_left(state):        ## LEFT
    temp=deepcopy(state)
    for row_i, row in enumerate(temp):
        for col_i, element in enumerate(row):
            if (temp[row_i][col_i] == '*'):
                r = row_i
                c = col_i
    if (not c == 0 and not temp[r][c-1] == 0):
            temp[r][c-1] = '*'
            temp[r][c] = 1
    else:
            return None
    return temp

def move_right(state):        ## RIGHT
    temp=deepcopy(state)
    for row_i, row in enumerate(temp):
        for col_i, element in enumerate(row):
            if (temp[row_i][col_i] == '*'):
                r = row_i
                c = col_i
    if (not c == 11 and not state[r][c+1] == 0):
            temp[r][c+1] = '*'
            temp[r][c] = 1
    else:
            return None
    return temp


def move_up(state):           ## UP
    temp=deepcopy(state)
    for row_i, row in enumerate(temp):
        for col_i, element in enumerate(row):
            if(temp[row_i][col_i]== '*'):
                r=row_i
                c=col_i
    if(not r==0 and not state[r-1][c]==0):
            temp[r-1][c]='*'
            temp[r][c]=1
    else:
          return None
    return temp


def move_down(state):         ## DOWN
    temp=deepcopy(state)
    for row_i, row in enumerate(temp):
        for col_i, element in enumerate(row):
            if (temp[row_i][col_i] == '*'):
                r = row_i
                c = col_i
    if (not r == 11 and not temp[r + 1][c] == 0):
            temp[r + 1][c] = '*'
            temp[r][c] = 1
    else:
            return None
    return temp

############################################ BREATH FIRST SEARCH ##############################################
def bfs(maz,goal,visited):
   
   n=create_node(maz,None,None,None)
   if(maz==goal):
      return [None]
   queue=[] 
   queue.append(n)
   current=n
   mov=0
  # current=queue.pop(0)
   while(current.st != goal):
          ## Expanding Nodes
          s1=move_up(current.st)
          s2=move_left(current.st)
          s3=move_right(current.st)
          s4=move_down(current.st) 
          n1=create_node(s1,current,'U',1)
          n2=create_node(s2,current,'L',1)
          n3=create_node(s3,current,'R',1)
          n4=create_node(s4,current,'D',1)
          temp=[]
          temp.append(n1)
          temp.append(n2)
          temp.append(n3)
          temp.append(n4)
          if (current.st not in visited):
            temp=[n for n in temp if n.st!= None]
            queue.extend(temp)
            visited.append(current.st)
          current=queue.pop(0)
   mov=len(visited)       
   path=[]
   res=[]
   sum=0
   print('###### NODES VISITED ######')
   for i in range(mov):
      stt=visited[i]
      for row_i, row in enumerate(stt):
          for col_i, element in enumerate(row):
              if(stt[row_i][col_i]=='*'):
                  print('[',row_i,'-',col_i,']')

   while(current.parent!=None):  ## Backtracking Path
       path.insert(0,current.operator)
       sum=sum+current.cost
       current=current.parent
   
   res=[path,sum,mov]
   return res

############################################ DEPTH FIRST SEARCH ##############################################
def dfs(maz,goal,visited):
   mov=0
   n=create_node(maz,None,None,None)
   if(maz==goal):
      return [None]
   stack=deque() 
   stack.append(n)
   current=n
   while(current.st != goal and stack):
            ## Expanding Nodes
            s1=move_up(current.st)
            s2=move_left(current.st)
            s3=move_right(current.st)
            s4=move_down(current.st) 
            n1=create_node(s1,current,'U',1)
            n2=create_node(s2,current,'L',1)
            n3=create_node(s3,current,'R',1)
            n4=create_node(s4,current,'D',1)
            temp=[]
            temp.append(n4) ## Appending in reverse order because of stack
            temp.append(n3)
            temp.append(n2)
            temp.append(n1)
            if (current.st not in visited):
                temp=[n for n in temp if n.st!= None]
                for i in temp:
                      stack.append(i)
                visited.append(current.st)
            mov=len(visited)
            current=stack.pop()
   path=[]
   res=[]
   sum=0
   print('###### NODES VISITED ######')
   for i in range(mov):
      stt=visited[i]
      for row_i, row in enumerate(stt):
          for col_i, element in enumerate(row):
              if(stt[row_i][col_i]=='*'):
                  print('[',row_i,'-',col_i,']')
   while(current.parent!=None): ## Backtracking Path
       path.insert(0,current.operator)
       sum=sum+current.cost
       current=current.parent
   res=[path,sum,mov]
   return res


############################################ MAIN CLASS ##############################################
def main():
    
    print('######## MAZE TO SOLVE ########')
    for row_i, row in enumerate(maze):
        for col_i, element in enumerate(row):
            print(maze[row_i][col_i], end=' ')
        print()
    print()
    visited=[]
    visited2=[]
    method = '############# BFS #############'
    print(method,'\n')
    result = bfs(maze, goal_state,visited)
    if result == None:
        print("No solution found")
    elif result == [None]:
        print  ("Start node was the goal!")
    else:
          print('TOTAL MOVES: ',result[2])
          print('PATH COST', result[1])
          print('PATH: ',result[0])
    print()
    method = '############# DFS #############'
    print(method,'\n')
    result1 = dfs(maze, goal_state,visited2)
    if result1 == None:
        print("No solution found")
    elif result1 == [None]:
        print  ("Start node was the goal!")
    else:
          print('TOTAL MOVES: ',result1[2])
          print('PATH COST', result1[1])
          print('PATH: ',result1[0])
    print()
    print('######### MAZE SOLVED #########')
if __name__ == "__main__":
    main()