# -*- coding: utf-8 -*-
"""A02_18I-1587.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1atbLnktD8fKj7Z-O3dDykhjPp8mvcZBT
"""

class Node:   ## Node class
    def __init__(self, row, col, parent, travelled):
        self.row = row
        self.col = col
        self.parent = parent
        self.travelled = travelled
        self.heuristic = 0
        self.final = 0

def printMaze(state, node):  ## print the maze
    state[(node.row*20) + node.col] = 8
    for index, i in enumerate(state):
        if index % 20 == 0:
            print('')
        print(i, end = ' ')
    print('')
    print('------------------------------------------------------')
    state[(node.row*20) + node.col] = 1

################################################ GREEDY BEST FIRST SEARCH #################################################
def GBFS(state, start_node, goal_node):
    open_list = list()
    closed_list = list()

    open_list.append(start_node)

    count = -1
    while len(open_list) != 0:
        #if count == 20:
        #    break
        count = count + 1
        min_final = open_list[0].final 
        min_final_index = 0
        for index, node in enumerate(open_list):
            if min_final > node.final:
                min = node.final
                min_final_index = index

        #print("Open List - ", count)
        #for i in open_list:
        #    print("(" + str(i.row) + "," + str(i.col) + ") - " + str(i.travelled) + " - " + str(i.final))
        #print("Closed List - ", count)
        #for i in closed_list:
        #    print("(" + str(i.row) + "," + str(i.col) + ") - " + str(i.travelled) + " - " + str(i.final))
        min_final_node = open_list.pop(min_final_index)
        #printMaze(state, min_final_node)
        closed_list.append(min_final_node)

        if min_final_node.row == goal_node.row and min_final_node.col == goal_node.col: ## if goal state found
            print("Path Found")
            print("No of moves utilized = ", count)
            print("Path Cost = ", min_final_node.travelled)

            return closed_list

        node_childern = list()

        index_in_state = (min_final_node.row * 20) + min_final_node.col
        if state[index_in_state-20] == 1:             ## UP
            new_node_row = min_final_node.row - 1
            new_node_col = min_final_node.col
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state+20] == 1:             ## LEFT
            new_node_row = min_final_node.row + 1
            new_node_col = min_final_node.col
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state-1] == 1:              ## RIGHT
            new_node_row = min_final_node.row
            new_node_col = min_final_node.col - 1 
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state+1] == 1:              ## DOWN
            new_node_row = min_final_node.row
            new_node_col = min_final_node.col + 1
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 

        for child in node_childern:
            add = True
            for nodes in closed_list:
                if nodes.row == child.row and nodes.col == child.col:
                    add = False
            
            child.heuristic = abs(child.col - goal_node.col) + abs(child.row - goal_node.row)
            child.final = child.heuristic

            
            for nodes in open_list:
                if (nodes.row == child.row and nodes.col == child.col) and nodes.final <= child.final:
                    add = False
            
            if add:
                open_list.append(child)
        
    print("No Path Found")
    return None

################################################ A* ALGORITHM #################################################
def A_star(state, start_node, goal_node):
    open_list = list()
    closed_list = list()

    open_list.append(start_node)

    count = -1
    while len(open_list) != 0:
        #if count == 20:
        #    break
        
        min_final = open_list[0].final 
        min_final_index = 0
        for index, node in enumerate(open_list):
            if min_final > node.final:
                min = node.final
                min_final_index = index

        #print("Open List - ", count)
        #for i in open_list:
        #    print("(" + str(i.row) + "," + str(i.col) + ") - " + str(i.travelled) + " - " + str(i.final))
        #print("Closed List - ", count)
        #for i in closed_list:
        #    print("(" + str(i.row) + "," + str(i.col) + ") - " + str(i.travelled) + " - " + str(i.final))
        min_final_node = open_list.pop(0)
        #printMaze(state, min_final_node)
        
        closed_list.append(min_final_node)
          
        if min_final_node.row == goal_node.row and min_final_node.col == goal_node.col:
            print("Path Found")
            print("No of moves utilized = ", count)
            print("Path Cost = ", min_final_node.travelled)

            return closed_list

        node_childern = list()

        index_in_state = (min_final_node.row * 20) + min_final_node.col
        if state[index_in_state-20] == 1:                ## UP
            new_node_row = min_final_node.row - 1         
            new_node_col = min_final_node.col
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state+20] == 1:                ## LEFT
            new_node_row = min_final_node.row + 1
            new_node_col = min_final_node.col
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state-1] == 1:                 ## RIGHT
            new_node_row = min_final_node.row
            new_node_col = min_final_node.col - 1         
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 
        if state[index_in_state+1] == 1:                 ## DOWN
            new_node_row = min_final_node.row
            new_node_col = min_final_node.col + 1          
            new_Node = Node(new_node_row, new_node_col, min_final_node, min_final_node.travelled + 1)
            node_childern.append(new_Node) 

        for child in node_childern:
            add = True
            for nodes in closed_list:
                if nodes.row == child.row and nodes.col == child.col:
                    add = False
            
            child.heuristic = abs(child.col - goal_node.col) + abs(child.row - goal_node.row)
            child.final = child.heuristic + child.travelled

            
            for nodes in open_list:
                if (nodes.row == child.row and nodes.col == child.col) and nodes.final <= child.final:
                    add = False
            
            if add:
                count += 1
                open_list.append(child)
        
        

    print("No Path Found")
    return None

def main():
    goal_state = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1,
            0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1,
            0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
            0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0,
            0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 3,
            0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,
            1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1,
            0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0,
            0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]

    start_state = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1,
            0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1,
            0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
            0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0,
            0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1,
            0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,
            2, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1,
            0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0,
            0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]
    goal_index = goal_state.index(3)
    goal_row = goal_index//20
    goal_col = goal_index % 20
    goal_node = Node(goal_row, goal_col, None, 0)

    start_index = start_state.index(2)
    start_row = start_index//20
    start_col = start_index % 20
    start_node = Node(start_row, start_col, None, 0)
    print("########### MAZE BEFORE... ###########")
    printMaze(start_state, start_node)
    print()
    print("########### MAZE AFTER... ###########")
    printMaze(start_state, goal_node)
    print()
    print("****************** A* ******************")
    A_star(start_state, start_node, goal_node)
    print()
    print("***************** GBFS *****************")
    GBFS(start_state, start_node, goal_node)
    print()

if __name__ == "__main__":
    main()